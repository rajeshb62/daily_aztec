 Transactions 9th of November 11, 04 PM. I am going through the concepts of Aztec, private roll-up. I started an account, gone all the way to storage, and partial issues, and mercury, and exclusion proofs, nullified trees, and special data structures that are used there. Our I-Wet Transaction Execution Transactions. On this page, transactions, on this page you learn the step-by-step process of sending a transaction on Aztec. The role of components like PXE Aztec node, ACIR simulation. It is a circuit simulator, and the sequencer. The Aztec kernel and its two circuits, private and public, and how the execute function calls. The call stacks are very, very useful. You can see how it reminds us of transactions completion. Simple example of the private transaction lifecycle. The transaction lifecycle for Aztec transaction is fundamentally different from the lifecycle of the Ethereum transaction. The introduction of the private execution environment provides a safe environment for the execution of sensitive operation, ensuring that the DQD data are not accessible to unauthorized applications. However, the PXE exists client-side on user devices, which creates a different model for the image, meaning what the lifecycle of a typical transaction might look like. The existence of a sequencing network also introduces some key differences between the Aztec transaction model and the transaction model used for the other networks. Descentralized sequencer. The accompanying diagram will state the flow of interactions between a user. They wallet the PXE, the node operators, sequences, Proverse and the L1 chain. Transaction lifecycle user. Connects wallet, inputs 10.2, good cost.Eath and click Transfer. PXE executes transfer method on token and computes state diff. Proves correct execution of auth and private transfer method via ZKP. Execution of auth is private, correct execution of signature. But yeah, authentication, which is the signature is valid. And private transfer method via ZKP. So it does by PXE. Now, validates TX, Prove, then executes plus proves public function and applies private state diff. What is valid? Okay, because it's approved that cent. Okay, validates the TF means it runs through the proof. Then executes plus proves public functions and applies private state diff. Oh, it's a note in nullified rate. How the hell does it know where to put the notes and nullifiers. When it doesn't know what's in the notes and nullifiers. Well, cryptographic magic, validates TX, Prove, then executes plus proves public functions. Applies private state diff. Validates roll-up proof, then that's the sequence error. Executes, validates executes plus proves public functions. Yeah, and applies private state diff. Yeah, and then roll-up is validate roll-up proof plus records new state rules. Oh, L1, L1, L1, L1, L1. Oh, see? Yeah. The user initiates a transaction. In this example, user decides to file consent and die to good cost. After inputting them on, the receiver address. The user clicks the confirmation button on the wallet. The result has been a broadcast with sequence network yet. For now, the transaction exists or wholely within the context of PXE. PXE executes, trans-trans-first locally. The transaction has still not been broadcasted to the sequence network yet, and continuously solely within the context of the PXE. The PXE proves correct execution. At this point, PXE proves correct execution, where as you know the proofs of the authentication and the private transfer method, once the proofs have been generated, PXE sends proofs and required inputs. Inputs have a new node commitment CSS, stored in the node hash tree, and then, alif-hye stored in alif-hye's tree. The sequence has nullifies our data that it will be. Inualit old commitments ensure that commitments can only be used once. Oh, far, this is fabulous. Man, sequence that is received the transaction proof and can begin to process the transaction. Very fine, proofs and applying updates to the relevant data tree, alongside other public and private transactions. The sequence is... The sequence has the necessary information to act, the randomly selected sequence, based on the Furnart sequence selection process protocol, validates OFAC. Fuf, sequence selected protocol, validates the transaction proofs, along with required inputs, example the node commitments and alif-hye's, for this private transfer. The sequence are also exegued private functions and request proofs of public execution from a provenette of the sequence updates, the corresponding data tree, and does the same for other private transactions. The transaction settles to alif-hye, the verified contract, and can validate the roll of proof and record a new state root. State root is submitted, sequence that way. Very, very, very compact. Shoof! Transaction, the Rastic Start with the call from ASTICJS, which creates a request containing transaction details. Why is it always ASTICJS? Why this request moves to private execution environment, which simulates... Then process is set, then the PXE interacts with the ASTIC node, which uses the sequencer to ensure that all the transaction details are in queue properly. The sequencer then submits a block to the roll of contract, and the transaction is successfully minted. The PXE interacts with the ASTIC node. The PXE interacts with the ASTIC node. What happens in ASTIC sandbox? Super, super, super, any transaction. ASTICJS is called ASTICJS, which provide a project from the call and constructor and contract deployment. Data is included. Signs at the DX execution, we owe you. I, I, I, I, I, I, I, I, I, you have to continue. O stick, O stick, O stick, O stick, same line. O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick all, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O stick, O a dx object is formed based on the information from execution result and output of the I stick no, okay, simulate. I stick no nads dx to the pool. I see. Sequencer picks up bending t-axis, okay. Sequencer submits the block to the block. The block contract, the block contract, the base of the state, the pool's new block. The pool's sub-block, the mark, the xe, no sandbox. From our cover and updates the void state, you will deploy contract is added to the contract stream, synchronizer, pool's new blocks and contract locks. Try with state, you know. Sequencer updates the state stored in the database based on the new block, I will update the property data and contract, re-arablated, prior digress, syntax, reload locks with encryption keys of a console, is stored in the pxe. New state, synchronizer updates the state stored in the database based on the new block, private data, public data and contractories are updated, trial decryption encrypted, logs with encryption keys of a console registered in the pxe and successful stores, nodes, they successful. The xe is settled included in the block. The xe is settled included in the block. The xe is settled included in the block. In the library, the public, the correct execution of a particular function call. Transaction is built up by generating proofs for multiple recursive iterations of kernel circuits. Each call is in the call stack in model-dust new iteration of the kernel circuit and managed by a fee for queue containing pending function calls. There are two called stacks, one for private, one for public. One iteration of a kernel circuit will pop a call off the stack and execute the call. If the call triggers subsequent contract calls, these are pushed onto the stack, private calls are generated first. The transaction is ready to move to the next phase when the private call stack is empty, the public kernel circuit takes in proofs of a public private kernel stack with an empty private call stack, the operates and operates recursively into the public call stack is also empty. The transaction is considered complete when both calls stack are empty. All private first-end public. All private first-end public. The little about the transaction is the number of private state updates triggered because some are over time-sacornal. Set up public calls carry generated. The public-state is public-state. As well as the functions that can operate on the standard data. As the public-state will be familiar to developers coming that have worked on other blockchains. Public-state is transferred to managed by a source for contract logic, internal to a public-state is stored and updated by the sequence of the sequence executes, state transactions and its proof of correct execution, publishes associated to treat our two-thirium. Private state must be treated differently from public state. This must be expressed in the semantics. This must be expressed in the semantics of a stick and are. Private state is inscribed and therefore is owned by user and set of users that are able to take full state by shared secrets. Private states that are presented in an app and only data was inscribed in a record would be weak information. Act of deleting private state, we don't can be open to bad things. So nullified nullified set, you know, such that without knowledge of the decryption key of the owner, the owner cannot link a state that a card with nullified. What application of state variables can be emulated by nullifying the state record and create a new record, a big push-over, a stick architecture and a way that it is made by K, is a big push-over. Structing UTXO's from apps and users, the goal of a stick dot in our smart contract, library is an abstract, the UTXO model away from an app user developer, contract developers are the only actors which should have to think about the UTXO. Contract developers are the only actors. Contract developers are ICC, app developer web app, the meaning is not a profit, they don't care, but as contract developers, they get to see it, who should have to think about UTXO's. This is a cheaply-tool-mink features, users sign over transactions, not over specific UTXS, a stack in our contract support developer divine and constraint data functions. To help apps make sense of UTXO's, get balance, this functions can be called a code code of transaction context to reprived it. I see this I see U.S. Tech, I see you, Fog, gross-in communication, see Alvin at the communication portals for information about how I stick communication with Alvin through portals. Private public execution for in-depth information about how private and public functions can call each other with the smart contract system. I see I see I know where that is. We want to go because we want to go there. Now, this is Alvin L2 communication through portals. In Aztec what we call portals are the key element in the Slating communication. In L1 L2, while typically typical L2 solutions rely on synchronous communication with Alvin L2, as the privacy of a nature means this is not possible. You can learn more about why in the previous sections section. Traditionally, Alvin will take communication, might involve direct calls between L2 and L1 contracts. However, in Aztec due to privacy component and the weight transactions are processed, can also be closed by the historical data. Direct calls between L1 L2 would not be possible if you want to maintain privacy. Traditionally, I want to communicate about indirect calls between L2 contracts. So, I stick due to the privacy component and the weight transactions are processed. We want to pass the information to privacy. Portals are, yes, portals are solution is problem at is bridges for communication between the two layers. These portals can transmit messages from public function in L1 to private functions in L2 and the same way it is worth the sense of being messaging while maintaining privacy. How portals enable privacy communication communication communication. We are available to our messages as sent, received and processed message boxes and how they work. How and why linking a contract between L1 and L2 are to occur? Objective. The goal is to set up a minimally complex minimal complexity mechanism. That will allow a base layer L1 and a stagnate worker to communicate arbitrary. Communication messages such that little functions can call L1 functions. L1 functions can call L2 functions. The role of block size have a limited impact by messages and their size. This document will contain communication abstractions. This document contains communication abstractions that will use to support interaction in the function of public function of the L1 portal contract, front of the instructions for the last take. The other one is to have very different executioner. This is to open an example of the L1 but the way it is. Private function calls are fully prepared and proven by the user. Public function is to be executed in the current head of the chain. Which only the sequence I can ensure or these must be executed separately to the private functions. Private and public functions within a stick. The first step is to create a function of the L1. The first step is to create a function of the L1. The first step is to create a function of the L1. The first step is to create a function of the L1. The first step is to create a function of the L1. The first step is to create a function of the L1. The first step is to create a function of the L1. The second step is to create a function of the L1. This can be regarded as message passing, providing a consistent mental model across all domains, which is convenient. Suppose the private function adds a cross chain call in such a case. The private function would not have knowledge of the result of the cross chain call within the same roll-ups since it has yet to be executed. Similarly to the ordering, private and public functions we can also read the benefits of intentionally ordering a secret word and two. The first step is to create a function of the L1. The second step is to create a function of the L1. The second step is to create a function of the L1. The second step is to create a function of the L1. Similarly in the ordering of private, similarly to the ordering of private and public functions we can also read the benefits of the order message between L1. The second step is to create a function of the L1. The second step is to create a function of the L1. The first step is to get it set up. The L1 can send an L2 to L1. The L1 will be added as the Rm. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L1. The L1 can send an L2 to L1. The L1 can send an L2 to L1. The L1 can send an L1. The L1 can send an L2. The L1 can send an L2. The L1 can send an L2. The L1 can send an L2. The L1 can send an L2. The L2 can send an L2. The L2 can send an L2. The L1 can send an L2. The L1 can send an L2. The L1 can send an L2. The L1 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L1 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L1 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The component helps with the correct execution of the abstract transactions. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2. The L2 can send an L2.