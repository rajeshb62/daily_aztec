 20th of November, 24 morning 1130, starting my session, I want to recount where I am on this whole account, I have went down the rabbit hole of understanding of weight and understanding the hard-coated account of from aesthetic docs last night, it was good, I made progress, I never know if my progress is fast enough, I just know it's not too fast for sure, I just don't know if I am slow, I see that the account, I count all the artistic account, hard-coated wallet firstly, the whole public key and the absence of private key was the baffling for me before this, then I found that there is a TypeScript binding that uses and calls and interacts with the hard-coated account and that contains the hard-coated private key, so this is just for, this is a toy account and sorry toy account, not for use but basically to study and learn, so that explains the mystery, it was always like the public key is here, because the private key, so the TypeScript binding has it, that is a big mental unlock because I thought it is more complicated than it is, or mind is standing was worse than it seemed so that lattified things, secondly the fact that there is binding to interact with it and therefore TypeScript to send transactions like and interact with the hard-coated account which means I can reproduce it in my astack experiment repo and therefore I will have a TypeScript binding to interact with my account with as I modified to create the astack silly account, silly astack account. So firstly the whole East-Warrid implementation which is complicated to me, you know, kind of follow it, right now it uses a snorr signature verification function from the standard library and passes the public hard-coated key, X and Y, so this is a bit that I do not understand that there are two fields for the public key, one field for the private key for snorr account that something I will reconcile, it is not such a major question in my mind. The second one is a astack, so it basically so it uses, it passes the public key, it is valid implementation here, it passes the public key which is hard-coated, the current in the implementation of NL file for the hard-coated account. First is the public key, second is the signature signature is essentially the auth-width, yeah, get auth-width which is which is which is function library available in the function available in the auth-width library of, you know, noir project, yes, astack packages, so it is available and that get auth-width, so you have the message hash, so which is the the big entire complete message hash which is the which is passed to the entry point two entry point and that is basically for that you get auth-width, so it is like an Oracle function, so when the auth-width is available the PXC provides it, trust of the work is done by the PXC, so when you get auth-width pass, do get the auth-width, so the PXC does the work, it sends the auth-width and that auth-width is used which is the signature, yes, so that becomes that is a signature, so the signature is used as an input, passed as an input, sorry is used as in easy-be's valid implementation, the public is already there, this is valid implementation, uses the Oracle passed value of signature, third is the outer hash itself which is basically the message hash yes, so these three are passed to the snorke, method from the snorle library verify snorke's signature, yes and then it passes yes or no, so what I can do, so that is mystery solved, so that I can completely pull out and I just replace it with let's say true, so each valid implementation will always return true, yes, so that is a silly mistake account per stage, so that is solved idea, so I understand what's happening in each valid implementation, is to check the valid implementation and you can report the contents of that method which is standard method in the auth-width library and then no project whenever I say auth-width library it is always part of the war project, yes, so it's an art library dot nr, no art library and not a TypeScript binding library yes, so which is all in the projects, so that's why you repout and replace it with this, so that is what I learned, this is actually yesterday's learning I should have put but last night was SpaceX launch 11pm of Tuesday of 19th of November, it was epic and therefore 11pm here and it was 1pm 12 when it ended and I just did not do the whatever it needed to do, all right, so let's go above above above, right and now I'm looking at, so that is easy implementing implementation, now the rest of the hard-coded contracted cells, there are two methods, one is the entry point method again and this calls the actions, account actions which is again all the methods for account actions, it's an object and with the bunch of methods already implemented, one to remember is where the implementation there is no default implementation in the library, for all the other methods, account actions once that are used, all have default implementations, so the account the entry point, it takes a fee pay fee payload, yeah fee payload and app payload and it basically passes these two to the it creates an account actions object and it's going to pass you know in it the initialize it the account objects by passing context yes, so context is private context within the PXE of the account and then also pass the is valid implementation called that that method it's going to pass so initialize with these two, so is valid implement is going to check authenticate that the signature is valid and then all these the stuff is available within in context yes, so the context contains all the new values needed by ease valid implementation and then it basically passes, so then it returns if you know once initializes is valid is correct then it calls the entry point method of the authorid library yes, so first it does out-uit action so action object of or tweet when you import it you also have an entry point method associated attached to this first is so that is one method important, second is there is this whole get private note yeah so that's essentially get private authвет here so that is essentially if you want to authorize the third party do action on your behalf so that is where that comes in that also first validates the signature by initializing the create an account object a context object validate is valid implementation that this is signed correctly and then after that you generate private authвет here private and then that is already in the that for implementation in a stick object yeah so these are all you can change the implementations but this is what I understood of hard coded so there is a lot of clarity that I have got is great progress towards creating my own you know the celiacont wallet to my liking yes but first what makes sense to me right now is to yes I mean look at the type script bindings and essentially interact with the token contract using the mostly much type script bindings a lot but I can also use the as take wallet to check public balances and public interactions and transactions on the sending the sandbox yeah so mostly it is type script bindings and then I will have a script in yarn script which I created yesterday but which gives wrong result and which I will improve to give me the interactions with the blockchain to let me interact with the blockchain called the method that I want so basically reproduce the simplest implementation of as take wallet send command line from the CLL abilities so this is good progress this is good solid progress and this is what I want to do play with the account token sorry token creation using type script gets get that successful and that should give me a lot more clarity on how the account hard coded account contract interacts and you know uses all the methods and then that is how I want to you know that I want to get once I nail them that I think that is going to be significant massive progress towards customization and improvement of my celiacs take wallet and that's all that is there in the first audio of the warning which I close and now I am going to create an audio transcript product.