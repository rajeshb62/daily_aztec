 Ok, time to come over. I am looking at the documentation ofactic, specifically the wallet, the concept of a wallet, and very basic, very simple. There is an origin contract. For being address, then there is something called payload, and then there is something called an entry point. So the entry point accepts the payload. Entry point is a private function, to solve it's private. So for the origin address, there is an entry point, and it always accepts different kind of payload. It will accept a private payload, public payload, norms, right? So whatever the payload comes, it will assign you to various different variables. So there is a basically extract total footprint. The private calls, function calls, the public function calls, then the third thing called a non-s. The port is in the signature, yes, it's a signature. So you know what I'm saying, what you do is, now using the private calls, public calls and norms, you drive the hash for it. What you do is, then you compare the hash, like the push for the verification, you call a verification function, which includes the hash, the public key, and the signature. And then it verifies that the signature and the hash and the public key, they match, right? That's what it does. So that is the account, and then after that, like what about, then what is, okay, once it's authenticated, okay, this is, like verified that, it's properly signed by the, by the owner of the public key. It is, then there is something private calls, so basically private payload is essentially, it is, you know, to contract, like which contract to call, then what are the parameters or inputs and third is values, so the values against those parameters. So those are the private calls that happen, and that is done, and then after that you call, which is, you make a function call, two address and, and the value, and the value is of it, that's what you do. And the value and the parameters, so you pass these three into the private call, okay, and then the public call, there is, there are these three things, there is a two, two method, there is, like two address, then there is the calls, then there is a private, then there is a parameters, then there is a values, then there is gas limit. So these are past, then you basically call the function call, then the two address, and then the parameters and the values, and then that's that defines the public. So this is literally the wallet, this is, this literally the account, like the user account, there is, and then what happens, like the wallet is basically a software, which works, which actually is very closely with the account, and it receives the payload from, from gaps, it receives the, you know, you have a payload basically, it constructs the payload, it receives a bunch of like the data, which it converts into a payload and calls it a contract, account contracts, which, does that, like it's in the, it verifies that it is in the, given the origin, it has public address, so that is all that is known, and given that, it basically, puts all the payload in the format that is expected by the account contract, and calls it a contract, account contract, if it is, okay, matching the payload that it expects, well it executes it, and then it, yeah, it first, authority is verifies the signature, and then it executes the functions, so that's literally, that's, in simple, all right, so one of the only criteria is that the entry point, so there is an entry point, then the entry point is the data, our non-s is the third thing, okay, so entry point is, is, is private, is all this, so that's one, there are what about non-s, okay, so non-s, the protocol doesn't ensure in a non-s, so, but so therefore, it's basically, what it does is it uses a nullifier, it to confirm that transaction has been executed, and if the same, it receives the same thing, then it doesn't execute, so that's how it does, so nullifier, so you can't send another transaction for the same, like, increase the gas limit for the same transaction, using the same non-s, so that's not possible, once you send a transaction, that's it, it implements, okay, so that is about the non-sand all these details, they account, and then we look at, account contract deployment, so we say that, well, account needs to be initialized, account needs to be deployed, why is it because everything is a smart contract? Though without deployment, you know your address, so receiver can always, you not deploy a sender, we'll have to deploy, and the gas can be paid by anyone, you know, you can actually, once it is somebody's address is assigned, the caller may populate it with the, sorry, yeah, so then there will be some basic dollar letters available there, and they account. Right, account, yeah, all right, let's go, then what is the essentialization, what is the, account initialization, yeah, so every account is a contract, yes, for purpose, I'll send you the contract, yeah, so you don't need to, yes, of course, yeah, so the shipping and the stock need it, so, so it needs to be deployed, yeah, so we can be interacted with, before they deploy, they are as far as it is to, yeah, so that's it, I'll give you the information, well there's account contract, the problem, so this is, we'll need to pay transaction fees, so this can be send in fees to the account contract address, okay, so anybody else, yeah, so, like, you can, deterministically it can be derived and, can fees just can be sent, if that deployment, so they have funds, alternatively the fee can be paid by another account using the contract, and the account can be paid, deterministically it can be sent to the account, before it's deployed, we have one contract address, authorizing actions, account contracts are expected, go not required by the protocol, to implement a set of methods for authorizing actions on behalf of the user, by, which is your, you know, verify the signature, verify the hash scheme, you need transaction, contract may call into the account contract and request a user authorization for a given action, I identified by a hash here, authorization is identified by a hash, this pair of items used for instance for transferring for a contract from an account that is not the color, well, it means something has one of the more to use, when executing a private function, this authorization is checked by requesting an auth written as from the execution or a key, well, what in this complicated idea, which is usually a signed message, okay, that is simple, there is an execution parking order, so, authoritness, I mean, well, authoritness is an exposed value, so, you can book for basically it's a signed message, for signed a signature, this is the authoritness, so, prior to the prior function, you want to expose the authoritness, the PXC is responsible for storing these auth witnesses and returning them to the request in the contract, so, a contract, if you have seen it basically your private and development execution environment, storing these auth witnesses and returning them to the request in account contract, so, a contract request, so, we got this, something I understood not entirely, auth witnesses can belong to the current user executing the local transaction or the user who share it out of bank. Yeah, it would be the local user executing this or somebody, another user shared it out of bank or the FAC does it mean. However, during the public function, execution is not possible to retrieve a value from the local or a good, FAC mean. It's to support authoritizations in public functions, account contracts should save a contract storage, what actions have been pre authorized by their owner. These two patterns combine, allowing account contract to answer whether an action is valid. For a given user, both in private and public context, you have something called this valid, you have a private context, and given these two private across all this, you know, two in the equivalent and equivalent public. There is no output, therefore it will have to be stored publicly. Should save the contract storage, what actions have been pre authorized, if it was in private, there is an auth with which the PXC is supposed to manage and handle and give it out to a method which is where the authorization is done. All right, okay, it means something, let's go. Okay, encryption and nullifying keys, how to take requires as takeaways use, define encryption and nullifying keys, okay. There are encryption and nullifying keys that are needed for receiving and spending private notes, unlike transaction signing, there's not transaction signing, there's not encryption key. Okay, it's encryption and it can nullifying is enshrined at the protocol. Fuck me. So, there's no transaction signing, but encryption nullifying is written in the protocol. This means that there is a single scheme used for encryption and nullifying. These keys are derived from a master public key. This master public key, inter and is used when deterministically derived in the account's fucking address. Fuck me. This is a single scheme used for encryption and nullifying, right, I see. It's enshrined, okay. So encryption and nullifying and trying to the protocol. Transaction sign is not. This master public key, inter and is used when deterministically derived in the account's fucking address. Oh fuck. So the encryption key, so it's for privacy. Signing is not enshrined, but execution encryption key is of this, so it can be it is often. There is a single scheme used for encryption nullifying. These keys are derived from a master public key. This master public key, inter and is used when deterministically derived in the account's fucking address. Oh, that's it. Pre-clude us. From having different public addresses for the same account, which is what account abstraction of Vitalik. Vitalik, the supposed to be addressed, does it fucking shank that? I mean, it's the same user, let's say. There was a very attractive account abstraction function. Where? There multiple. There are multiple public fucking keys, huh? Destination addresses, huh? And also, every transaction you sign. So, the signing key changes. So for the same account, you may have different signing keys. Well, let's say, you need different signing keys for different types of users. Yeah? So let's say you want to have automated out payment out, huh? So you have a different sign in key. So you have a gaming mode, okay? When you're playing a game, then you have a separate sign in key. All right? Fuck me. Fuck. There you have it. An encryption and nullifying key. As take requires users to define encryption. Oh, ho ho ho ho. Yeah, so they do their enshrined. You fucking have one public address. And it is derived from the encryption key. And also the same is the nullifier key. That is the fucking enshrined one. So therefore, there is the only one master public key. A side effect of coming to the master public key as part of the address is that this key cannot be rotated. Fuck, it's hell. While in a contract implementation could include methods for rotating that signing rhetoric in the signing key. It's unfortunately not possible for encryption and nullifying keys. Not that rotating nullify keys also creates other challenges, such as to maintain the advancements. We are scoring users of which are shared mutable to enable rotating keys. That will be cool. While we entertain the idea of obstructing note encryption, where account contracts would define an encrypt method that would be used a user-defined scheme. There are two main reasons we decided against this. First is that the sentator that in order to receive funds, the user had to first deploy their account contract, which is a major US issue. That fucking man, do it what the fuck. Second users could define malicious encrypt methods that failed in certain circumstances, breaking application flows that required them to receive a private note. While this issue already exists in Ethereum, then transferring it. It's in fact made worse in Aztec since any execution payload in the privacy function, it makes the entire transaction unprovable. It is not possible to catch errors in calls to other private functions. What can I have? And furthermore, because encryption is required for any private state. Not just for transferring it. Nevertheless, both of these problems are solvable. Initialization can be worked around by embedding a commitment to the bytecode in the address and removing the need for actually deploying contract, interacting with them. And the king of the hill issue can be mitigated by introducing a full private VM that allows cached-catching rewards. Aztec, we may be able to obstruct the transcription in the future as well. Okay. Thank you. Fuck in air. Please do. Yeah. Okay. In order to be considered valid, and account must prove that it has locked enough funds to pay for itself. Yeah. However, this does not mandate where those funds came from. This way abstraction allows for easy implementation of pay masters or payment in kind via on the fly swabs. However, there is one major consideration around public execution towards. The current design is one of the public function executions and queue in the transaction fails. Then the entire transaction is devoted, but rewarding the whole transaction will also reward the payment. And leaves, leave the sequencer with their hand and empty after running the public execution. Public, what does it mean? Public execution, in the current design, if one of the public function executions and queue in a transaction fails. The entire transaction is devoted, but rewarding the whole transaction will also reward the fee payment and leave the sequencer with their hands empty after running. This means we will need to ensure an initial verification and fee fee payment pays that is not rewarded if public execution kills. Okay. All right. I mean, you will implement it. Let's go to authVitness. Which is a part of accounts. Accounts are simple. Authentication withness. Authentication is key for authenticating actions and asstick. So users can allow third parties. Example protocols are very users to execute in an action on their behalf. When building defey smart and other smart clients often decide to interact with other contracts. So it's a good same action on behalf of the user. Yeah. As long as there's authorization by user. For example, when you want to deposit funds into a language protocol, protocol wants to confirm it. Transurotius will need to post some of the user account. You can't get a project on it. Yeah. Let's go. Yeah. Maybe a word. This is often accomplished. User approved protocol. Under account and then calling it deposit fucking function on leftovers. Fuck in hell. Yeah. This room makes it rather simple for the application developer to implement with deposit function. But does not come with it. Yeah. Yeah. Come through this downside. One main downside is UX. Yeah. That's exactly what's a bunch of other issues. User makes two transactions without any doubt that's a problem for the approved end deposit. To limit the announced for return users. Some front end will use the approved function with an infinite amount which is fucking bad. This can lead to absolutely fucking. You don't need to tell me. Fuck in shit. To avoid this, many protocols implement the permit flow. Which uses a matter transaction to let the users sign the approval of chain. Or which is like cow swap does. Fuck in hell. And pass it as an input to the deposit function. That way the user only has to send one transaction to make the deposit. Some shit. How does permit function work? Which is the new unit swap. Method. It's a great improvement to infinite approvals. Yeah. Yeah. Pass it as an approval. So there is a year, 1271. For example, if the user is using a smart contract wallet, such as agent or narcissist save, they will be able to sign the permit message in the usual. Signature validation does not work well with contracts. The AP12701 is proposed to give contracts to a minute this but it is not widely wrapped there. Separate the message that users sign can see a pick. The user and the minute understand what they are. Absolutely. Fuck in hell. Generally you should approve as well. All of these issues. Fuck in hell. Haven't discussed in the community for a while and there are many proposals to solve them. How none of them have been widely adopted. They are in the so commonly used. And changing standard is fucking hard. Absolutely right. Inastic. Out of the year 2020 forastic is not as simple as it might seem because of private state. The private state is generally known by its owner and those they have shared it with. Because it relies on secrets. Private state might be owned. But the fuck. Is hybrid state model. Fuck now. All right let's go. Huh. Out of the way. Yeah. Nastic. There is something called hybrid state model. Private state is generally only known by its owner and some of those were shared with. It might be owned by contract. Because it relies on secrets. Private state might be owned by the contract but need someone who knowledge of these secrets. Actually it's penned. You might see where this is one. I don't see where it's going. If we were to implement the approval with an allowance in private you might know that. Allowance. No no no. But unless you also know about the individual note that make up the user's balances. It would be of no use to you. It's private after all to spend the user's funds. You need to know the decryption key. Seek is for more. Yeah I'm going to seize this for more. If you were to implement the approve. With an allowance in private you might know the allowance. But unless you also. No about the individual note that make up the users balances. Yeah it would be of no use to you. Just private after all. To spend the user's funds you need to know the decryption key. Well this might sound limiting in what we can actually do. The main use of approvals have been for simplifying contract interactions. The user is doing the case of private transaction. This is executed on the user device. So it's not a blocker that the user need to tell the executor a secret. The user is the executor. Yeah. Okay the private transaction is executed on the user device. So it's not a blocker that the user need to tell the executor a secret. The user is the executor. Yes user interaction. So users contract. No, all the notes. And he's also the executor. So there for. Not a blocker. To kind of. Approve an allowance. A few more things we need to remember about private execution. Stay private. It all happens from the user device. Because it happens from the user device. Additional user provided information can be passed to the contract. Mit execution by an oracle. Yeah. Focking oracle. Focking oracle. Let's go. Oh we're not done yet. Foking now. Hmm. The user provided information can be passed to the contract. Mit execution via an oracle call. After the contract. For example when the private transfer to the wallet. Maybe provided the notes that will use the ones to transfer to one of these. So we're not done yet. It's an oracle is. You've already. Emitting off. Let's a transfer of funds to the receiver account. And receiver account is doing something. transactivity depends on the notes which this guy this Oracle is sending midway and that is used to do further transactions like so in the we are. So that is like you have to receive something to spend it. So you may like the what you the note the details of the note that you will spend become why Oracle later. This allows us to keep the function signature simple and have the user provide the notes they want to transfer through the Oracle call. Yeah okay. So there is going to be an Oracle call. And that may carry the notes. Yeah and since it's private and this user is executed so it may work. For a transfer it could be notes provided but we could also use the Oracle to provide any type data to the contracts so we can borrow the idea from permit that the user can provide the signature to the contract which allows it to perform some action on the application. So Oracle can provide the signature to the contract with the initiative of the machine. Okay okay it's a special box goodness or signature the box refer to the written as instruction signature because it is not necessarily a signature that is required to convince the account contract that we are allowed. Before the action depends on the contract implementation and it could also be a password or something similar. Absolutely. Absolutely. Since a witness is used to authenticate or someone can execute an action on behalf of the user. We call it the authentication witness for short an action in this meaning is a blob of data that specifies what call is approved what argument it is approved with and the actor that is authenticated to perform the call. In practice this blob is currently outlined to be a hash of the content mentioned but it might change over time to make simulating simulations easier. But the fuck is simulating simulations. It's a link hyperlink that goes to different ways. So what authorize so we can check what other is required by transaction with the initial simulation. Okay. Well it end with the user and then proceed with the actual simulation. Okay. All right. So you simulate to know what the op witnesses are needed. All right. All right. Let's go. Yeah. Simulating simulations. All right. We have the following we have the edges not friendly hash function and the odds hash is the hash function argument. All right. It's not fucking a hell. It's a little too fucking close. And the odds hash is the hash function argument. Okay. A big addition in transaction which is a hash. All the contract selector odds hash. Okay. So a little bit an example as mentioned earlier. Let's say that we have a token that implements our food such that transfer funds from it to be valid defaced during the transfer. Yeah. Or there is a witness that authenticates the caller to transfer funds from this account. While this specifies of spending rules. One must also know of the notes. She used them for anything. This means that the witness in itself will only have to implement. Oh yes yes yes. Okay. And note the price. Do this thing. Okay. Yeah. Okay. So you need to note the notes. All right. Have a video so far. Kind of. A little bit. To outline an example mentioned earlier. Yeah. Yes. We have been information trading in the authentication action for the transfer of funds to the defied contract. We look like this. Yeah. We need to know the notes. Main. Action is the hash of. Defied. Okay. The token. All right. Defied is let's say the lending protocol contract. Token is the token contract. Yeah. The transfer selector. The fuck does that come. H hash of alisa count defied which is the smart contract. Okay. Yes yes. So alisa count has given contract defied an approval of 1000 which is essentially the. Fuck. Yeah. Witness that authenticate the color to transfer funds. Yeah. So it's not just 1000 that you need. But you know what the transfer now selects. To the selector the function selector. So which is which function of that contract. Of the remaining contract. Or which. Yeah. To deposit. Let's essentially. The deposit. Reading the authenticate action for the transfer of funds to the defied contract. We look like this. Defied allow to call token transfer function. Yeah. Yeah. Transfer selector is the selector to call the transfer function on the token contract. Yeah. While the token transfer function is the argument. Alisa count defied and 1000. This out of the way. Let's look at how this would work in the graph below. All right. Let's look at the graph below. The exact contents of the witness. Okay. The file allowed. All right. With this out of the way. Let's look at how this would work in the graph below. Is that content with witness? We'll differ. With winning implementations as mentioned before. All right. Fuck. Keep the witness in order. Is it the top of the hash? Has function. Vo Dis sollte. Hmm. Okay. Do we need a worldwide component? We're waiting for some bombs in the dummy lobby. There ain't any goodborough Time for the shopping mall. which they account contract can then be used to validate if it really should all of the action. So, if you are talking about here, Alice, there is a authentication of it. What is that let us say signature that this defi can be this defi can spare transfer is for must to itself. So, authentication witness is that this is not for defi calling transfer. So, if it is not for transfer is defi, then given to Alice can't Alice near the course. And then, of course, then there are contract. Yeah, contract should defi me calling if it dies again. Then if it transfers deposit. Yeah, so it transfer, it gives her quit. Yes. So, this valid. And for if you mall it transfer is defi 1000 success. The proposal is initial. I see. Okay. Yeah. So, there is one deposit. The first instruction from contract Alice contract. And then based on back the tasks for this thing. And then that task for Alice's fucking information. So, Alice serves. So, it is the same time. Alice, signs. Alright, I think I had some bit of say. What do they contract for checking authentication should be a static call. Meaning that it cannot change state or make calls that change state. This call is not static. It could be used to reinvent the flow and change the state of the contract. Okay. Something like fucking ray of interest. Yeah. There is intrinsic. That's not good all here. We could use the AC20 standard for public. Okay. But this seems like a waste. Then we have the ability to try writing some round. We still can expand our audit. It's keen to also work in public. Okay. What about public? Okay. Okay. Okay. Okay. Okay. This is actually quite simple. Let me see what happens while working on it. It's actually quite simple. It's just a musting in Oracle which we can't do as easily because it is not private execution. What the fuck is that? Oracle that. Okay. Because not a private execution. You can just store the earthquake in a shared registry. And look it up and we need it. While this needs the storage to be updated ahead of time can be sent to X. We can quite easily do so by batching the awkward updates with the interaction. A benefit of a concontract. That seems awkward updates. A shared registry is used such that the execution from the sequinsors. One of you will be more straightforward and predictable. For the most since we have the authorization data, directly in public state. With a both set and unset, in the same transaction there will be no state effect after the transaction for the authorization. For the most since we have the authorization data, we have the public state. The both set and unset, in the same transaction, there will be no state effect after the transaction for the authorization. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The two set and unset, in the same transaction, there will be no state effect. The same transaction cannot be authenticated twice. If you want to follow the same transaction to be authenticated multiple times, we should include a non-send the arguments. So, as the action is different each time. The transfer this could be done simply by appending a non-send argument. Beware that the account contract will be unable to emit the nullifiers since it is checked with the static call. So, the calling contract must be it. This is similar to non-senshing RCT20 tokens today. We provide a small library that handles this. The difference is that we are not setting up an allowance, but allowing the execution of a specific action. We decided on this option as a default since it is more explicit and the user can agree exactly what they are signing. Also most users of the approvals are for contracts where the following interactions are called by the users themselves. So, it is not a big issue that they are not easily transferable as the permits. Also most users of the approvals are for contracts where the following interactions are called by the users themselves. So, it is not a big issue that they are not as easily transferable as the permits. Other use cases we do not need to. Next we do keys. The goal of this section is to give app developers a good idea what keys they are used in the system. For a detailed description head over to the protocol specification. Okay. Right. So, you only note the logs that they sent to you. So, it is private. I see. Somebody shared a view that they can see the data well. And I will go in view only to view any logs or notes used into another entity. A tagging key to quickly pick find notes relevant to you and oftentimes in a sign key. And I will take that as a promise that you can change the encryption key. The sign key is not strictly required by the protocol but are often used with specific account contracts for approvals. And in the view in key pair used to encrypt the note for its sequence and insisting of the master and community use secret key in the master and community of the key. Now if I keep air used for note nullify computation comprising a master nullify secret key and master nullify public key. Yeah. And incoming viewer key pair used to encrypt the note for the received and consisting of the master and community use secret key. The master and community public key. Yeah. And then again in key pair. There's a public key and you can see it key. A tagging key pair used to compute tags in tagging note discovery schemes. Comprising a master tagging secret. And then the master tagging key. And then the master tagging key. And then the master tagging key. And then the master tagging key. And then the master tagging key. And then the master tagging key. And then the master tagging key. And then the master tagging key. And then the master tagging key. And then the master tagging key. And the master tagging key. And the master ask it's headers. Oh. And then here's only onepadgash dash. We've got the red buff here. the keys for our accounts can be retrieved from the private execution environment using the following geter in a stick. The function get public keys account address or a bit fucking keys. Count address public keys. This message is read to first register the user as an account in a PXA. By calling the register account PXA and point using the stick. So while doing the account secret key and partial address. The key is used for the same user in two different applications contracts will be different and potential will be of the scope. The key is to only affect one application I see. This also allows for application or a utility. I use a method to disclose the incoming and outgoing unit based or give an application to an auditor or regulator. As a means to reveal all their activity within that context while returning privacy across all of the applications. Very much so. So amazing. In the case of nullify keys there is also a security is involved. Since the nullifier secret is exposed to the application contract to be used in the nullify computation the contract may accidentally maliciously leak it. If that happens only the nullifier secret for their application is compromised. If the nullifier secret is exposed to the application contract to be used in the nullifier computation. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. About we mentioned that the note typically contain NPK and the scourm it might seem like a mistake even that the note is nullified given the scale and the scourab. This is intentionally instead of directly trying to derive NPK and the scourm from anus can to scourab. We instead verify that both of the keys were derived from the same NSKM in our protocol circuit. If you are curious how the derivation scheme works, I'd order to put a first description. All right. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. An application in a stick.NR can request a secret from the current user for computing the nullifier of a note. Why are the requests on the nullifier circuit here? So we saw that it's a nullifier. Okay. Function. Computenally file. Cell context. My private context. Note hash for nullify field. I'll put a field. Let owner NPKM and scour hash field get public keys. Let's secret equals context request and is key and scourab. Yeah. Okay. Okay. Okay. IVPK is used to encrypt a note for a recipient and the corresponding secret key is used by the recipient during the kitchen. Okay. All going to use apps and versions of all going to use. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. The following section we have a few ways how an account contract would be architected to store signing keys. Sign is to use the private note. Yeah. That's what the idea is to do a day. When we signed the payment, we signed the entry point function. The result is that we signed the entry point function. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. Okay. So let's go back to line cut off a little bit. As well as imposing restrictions on how fast keys can be rotated due to minimum delays. Reusing some of the import of all keys is possible to use some of the key pairs defined in protocol, example incoming Vuin keys as the sign key. Since this key is part of the address pre-match, more on this on the privacy master key section, you can be validated against the account contract address rather than having to store it. However, this approach is not recommended since it reduces the security of the user count. This possibility use some of the key pairs defined in protocol, example incoming Vuin keys as the sign key. Since this key is part of the address pre-image, more on this on the privacy master key section. It can be validated against the account contract address rather than having to store it. However, this approach is not recommended since it reduces the security of the user count. Using a separate key store. Since there are no restrictions on the actions that an account contract may execute for authenticating a transaction, as long as they are private function executions. The signing public keys and be stored in a separate key store contract that is checked on every call. This will incur in a higher proving time. In a higher proving time for each transaction, but has no additional cost in terms of fees and allows for easy key management in a centralized contract. When deploying a contract, the contract addresses deterministically derived using the following scheme. When deploying a contract, the contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. Typically, for a long contract, the public keys will be non-zero and for non-a-concontract zero. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is contract plus a contract plus a contract. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is deterministically derived using the following scheme. The contract address is very derived from the same thing. The contract address is deterministically derived from the following scheme. The contract address is deterministically derived from the following scheme. The contract address is deterministically derived from the following scheme. The contract address is deterministically derived from the following scheme. The contract address is deterministically derived from the following scheme. The first step for any wallet is to let the user set up their accounts. The contract address is deterministically derived from the following scheme. The contract address is deterministically derived from the following scheme. The contract address is deterministically derived from the following scheme. The contract address is deterministically derived from the following scheme. The contract address is deterministically derived from the following scheme. The transaction proofs are generated on the wallet and not on a remote node. The contract address is deterministically derived from the following scheme. The contract address is deterministically derived from the following scheme. The execution request or one of the more function calls to question by that. For example, a dad may request a wallet to invoke the transfer function on the contract with the following arguments. The transaction is in response to a user action. The wallet is in an execution request with the signed instruction. The contract address is in an execution request. The transaction calls in the entry point payload and includes its eCDS signature with the account signing private. The transaction class ID is for contract class ID. The wallet is responsible for simulating and proving the execution of the expired functions. The simulation gives an execution trace which can be used to provide the user with a list of side effects of the private execution of the transaction. During the simulation the wallet is responsible for providing data to the virtual machines as a private node and PIPS and keys on the nullify secrets. Simulating and proving the execution of expired functions. The simulation yields an execution trace which can be used to provide the user with a list of side effects of the private execution of the transaction. During the simulation the wallet is responsible for providing data to the virtual machine. Such as private nodes encryption keys on nullify secrets but the fuck is a virtual machine. This execution trace is fed into the poor which returns a zero-ish proof that guarantees correct execution and height-sol private information. The output of this process is a transaction object. Yes. Protç‰© application Transaction object. Weber execution, trace of the transaction is exhausted by the node todo. is important. Since these notes are immutable, the trace of a transaction is always the same. So any effect is observed during simulation will be exactly the same in the transaction. It is mine, however the transaction may be dropped if it attempts to consume a private note that another transaction only 5-8, before it gets mine, note that this applies only to private function execution. Public functions rely on an account models in the or to Ethereum for the execution trace depends on the change public state at the point there included the block which may have changed since the transaction is similar to local leaf. Finally, the wallet change that is resulting transaction object which includes the proof execution when I stick note. The transaction object transaction is then broadcast at two the peer to peer network. To be eventually picked up by the sequencer and included in a block. We eventually picked up by a sequencer and included in a block. Then broadcast it through the peer to peer network. To be eventually picked up by a sequencer and included in a block. For lovely, lovely, lovely, lovely. Authorizing actions. Account contract in the SDK expose an interface for other contracts to validate whether an action is authorized by the account of not. For example, account contracts in a SDK expose an interface for other contracts to validate whether an action is authorized by the account of not. For example, an application contract. May want to transfer tokens on behalf of a user in which case the token contract will check with the account contract whether the application is authorized to do so. These actions may be carried out in private or in public function in the transactions originated by the user or by someone else. Will it manage these authorizations prompting the user when they are requested by an application. Authorizations in private executions come in the form of author witnesses. Which are usually signatures who are in identifying for an action. How would an identifier, which may be private key or it may face ID etc. Prior password etc. Applications can request the wallet to produce an author witness via the create-out-with-call in public functions. Authorizations are pre-stosed in the account contract storage which is handled by a call to an internal function in the account contract implementation. As in EVM based chains, wallet are expected to manage user keys or provide an interface to hardware wallets or alternative key stores. Keep in mind that inastic each account requires two sets of keys and authentication keys. Yeah. There let's go back again because prompting the user when they are required by an application. Wallets should manage these authorizations in private execution come with the form of author witness. Which are right. Public function of reasonable pre-stored in the account contract storage. Hmm. Which is handled by a call to an internal function in the account contract implementation. Which just discussed the private keys and the internal storage sign key and then you take it out and then you do something. Whereas in the case of private visits and all purpose. He management. As in EVM based chains, wallet are expected to manage user keys or provide an interface to hardware wallets or alternative key stores. Keep in mind that inastic each account requires two sets of keys, privacy keys and authentication keys. Privacy keys are mandated by the protocol and used to encryption, use for encryption, nullification. Whereas authentication keys are dependent on the account contract implementation road or by the wallet. So if we account contract supported, wallets must provide the user with the means to rotate or recover their authentication keys. Key are dependent on their account contract implementation, full-door federal wallet. Yeah. Should their account contract support it wallet must provide the user with the means to rotate or recover their authentication keys. Must provide. EPS account contract supports it. ECPN entry encryption keys. Wallets are also expected to manage the public encryption keys of any recipient of local transactions when creating an encrypted note for the recipient given their address. The wallet needs to provide their complete address. Public encryption keys. Of any recipient of local transactions, when creating an encrypted note for a recipient given their address, the wallet needs to provide their complete address. The CPN's broadcasts their complete addresses when deploying their account contract and wallets collect this information and save it in a local registry for easy access when needed. Note that in order to interact with the recipient, who has not yet deployed their account contract and does not broadcast their complete address it must also be possible to manually access their addresses. When creating an encrypted note for a recipient given their address, given their address. Oh, right. I try to complete encryption keys of any recipient. Oh, they are very public address. Wallet needs to provide their complete address. The wallet needs to provide their complete address. To see if you just carry it, the CPN's broadcasts their complete addresses when deploying their account contract. And wallet's collect this information and save it in a local registry. Hmm. For easy access when needed. Oh, in order to interact with the recipient, who has not yet deployed their account contract and does not broadcast their complete address, must also be possible to manually add an entry to the wallet's local registry of complete addresses. Last, not the least, Wallet's also store the user's private state. While it's currently rely on brute force decryption, where every new block is downloaded and its encryption data blocks are attempted to be decrypted with the user decryption keys whenever a blob is decrypted properly, is added to the corresponding account private state, not that the payment of a user's account contract. Since users may have received private state before the payment. Store the users' private state. Wallets currently rely on brute force decryption. Hmm. Private state. Wallets currently rely on brute force decryption. Where every new block is downloaded and its encryption data blocks are attempted to be decrypted with the user decryption keys. Whenever a blob is decrypted properly, it is added to the corresponding account private state. Note that Wallet's smart also scan for private state in blocks. Prior to the deployment of a user's account contract, since users may have received private state before the payment. All publisher, encrypted and bought cash check through the network and eventually committed to a one. This means that a wallet can reconstruct its entire private state out of its encryption keys at the event of local data blocks. Of course, fabulous. Encrypted data blocks do not carry any public information as to whom they received entities. Therefore, it is not possible for a remote node to identify the nodes that belong to a user and it is not possible for a wallet to query a remote node for its private state. As such, wallets need to keep a local database of their account private state in order to be able to answer any queries on their private state. Therefore, it is not possible to remote for a remote node to identify the nodes that belong to a user. Yeah, and it is not possible for a wallet to query a remote node for its private state. As such, wallets need to keep a local database of their account private state in order to be able to answer any queries on their private state. Daps may require access to the user's private state in order to show information relevant to the current application. For instance, a DAP for a token may require access to the user's private nodes in the token contract. In order to display the user's balance, it is a responsibility of the wallet to require authorization on the user before disclosing private state to adapt. This page talks about the architecture of a wallet in Aztec, wallets exposed to DAPs and interface that allows them to interact on behalf of the user, such as querying private state or sending transactions. Hearing mind that as an Ethereum, wallets should require user confirmation whenever carrying out the potentially sensitive action requested by DAP. Overview, architecture wise a wallet is an instance as of a private execution in the one-ment which manages user key and private state keys and private state. The PX also communicates with an Aztec node for a driver for public information or broadcasting transactions. Note that the PX requires a local database for keeping private state and is also expected to be continuously sinking in blocks for trial decryption of user nodes. Additionally, a wallet must be able to handle one or more account contract implementations. When a user creates a new account, the account is represented on chain by an account contract. The wallet is responsible for deploying and interacting with this contract. A wallet may support multiple flavors of accounts, such as an account that uses easy-seasy signatures or one that relies on the bot or one that requires multi-factor authentication for user the choice of what a account implementation uses then determined by the wallet the interactive. Hmm. By an account contract, when a user creates a new account, the account is represented on chain by an account contract. The wallet is responsible. The wallet is responsible for deploying and interacting with this contract. A wallet may support multiple flavors of accounts, such as an account that uses easy-seasy signatures. Or one that relies on the bot or one that requires multi-factor authentication. For a user, the choice of what a account implementation uses is then determined by the wallet the interactive. In code, this translates. In code, this translates to a wallet implementing and account interface interface, that defines how to create an execution request out of an error function calls for the specific implementation of an account contract and how to generate an hotwoodness for uprising actions on the whole user. Think of this interfaces, the JavaScript account part of an account contract. Yeah. Think of this interfaces, JavaScript, counterpart. The specific implementation of a contract can help with the update and outputness for uprising actions on the user. Think of this interface with the JavaScript account, about a phone contract. Of the piece of code that knows how to format a transaction and authenticate an action based on the rules defined by the user's account contract implementation. That knows how to format a transaction and a authenticate an action based on the rules defined by the The account interface that the account interface is used for creating an execution request out of one of more function calls requested by the app. As well as creating an outputness for a given message hash, the account contracts are expected to handle multiple function calls for transaction since apps may choose to batch multiple actions into a single request to the wallet. Account interface. Support into Vizor Fitness Provider. Create a output. As well as creating an outputness for a given message hash. Account contracts are expected to handle multiple function calls for a transaction. Yeah, since apps may choose to batch multiple actions to a single request for the wallet. Interesting. Account interface. Export interface. Auth sweetness provides creates authorization witnesses. Computes an authentication witness to signature from either a message hash. Your authentication witness. Message hash to approve. Returns the authentication witness. Create AuthVith. Message hash. This is a field element buffer. Promise AuthVithness. Handler for interfacing within account knows how to create. Transaction execution requires and authorize actions for disguise pointing account. Export interface. Account interface extends entry point interface. AuthVithness Provider returns the complete address for this account. Get complete address. Get address. Then get address. This is a mistake address. Get chain ID. Which is a field element. Get version. Which is a field element. Polluporsion for this account. Chain ID for this account. Polluporsion. Okay. There's a rolluporsion. I mean multiple. Okay. The latest portion. The previous version of Hashtag. New version of Hashtag whenever there is a. Okay. Returns the address for this account. Get address. Hashtag address. A, A, A, A, A, A, A, A, A, A. You can see interface. Yeah. Get chain ID. Get version. Also, it does it does it does. So that's the interface. Get complete address. Or through it for or through which has provided. Export account interface. For the interface. Extend centred point. To interface or through this provider. Aha. Get complete address. Get address. Get chain ID. Get version. I see. Okay. Get or fit. Support interface. A wallet exposes. The PX interface. To that by running a PX instance. The PX requires a key store. And data was implementation for storing keys. Private state. And recipient. And encryption. Public keys. PX interface. Export interface. PXC. Add. Aut sweetness. Get ortho witness. Capself. Register account. Get registered accounts. Get registered account. Register contact. Get contracts. For the what is this? PX interface. A wallet exposes the PX interface to that by running a PX instance. The PX requires a key store. And the data was implementation for storing keys. Private state. And recipient. Encryption. Public keys. Unsclocally for each user. Need to hit. If you have a technique work. Fork. It's not a wallet. Come on. Export interface. PXC. Add. Witness. Get ortho witness. Add. Capself. OK. On top of the. OK. Look. Let's look at the interface. wallet exposes the PX interface to that by running a PX instance. The PXC. OK. Before that is a content interface for the account. OK. That makes sense. Right. Right. The previous one. Interface ortho witness provider. Right. For your account. PXC interface. Ortho witness provider. And interface. Interface account interface extends. And to point interface. So it creates the P-loop. A wallet exposes. Yeah. Yeah. Yes. PXC. OK. Now next is PXC interface. wallet exposes this for the apps. So private execution environment runs locally for each user. It needs to interact with the asset network including account management, private data, avoiding functionality for all the operations. Need it to interact with the asset network including account, account management. Functions. Functionity for all the operations. Need it to interact with the asset network. Shooting account management. Private data management. Transaction local simulation. And access to an asset network. This interface as part of a wallet is exposed to apps for interacting with an network on the other user. This interface as part of the wallet is exposed to apps for interacting with an network on the other user. This interface as part of a wallet is exposed to apps for interacting with an network on the other user. Yes. So the apps for interacting with an network on the other user. Export interface PXC. Insert an outputness for a given message hash. What witnesses are used to authorize actions on the user. For a given message hash, what witnesses are used to authorize actions on the user. For instance, it is broken. For a given message hash, what witnesses are used to authorize actions on the user. The user can't transfer initiated by different address may request authorization on the user for move their tokens. This authorization is granted by the user account contract by veriting an auth goodness requested to the execution oracle. Rented by the user account contract by verifying yes. Witnesses are used usually a signature or a hash of the action to be authorized. The signature or the hash, but their actual contents depend on the account contract that comes in. This authorization is granted. For instance, to transfer parameters is auth goodness. Export interface PXC. The auth goodness to insert composed of an identifier which is the hash of the action to be authorized and the actual witnesses as an arrow fields which are to be decirilized and processed by the account contract. The auth goodness to insert composed of an identifier or witness. This is the email password signet by veriting which is the hash of the action to be authorized and actual witnesses as an arrow fields which are to be decirilized and processed by the account contract. Fetch is the serialized auth goodness for a given message hash or returns undefined if not found add auth goodness. Fetch is the serialized auth goodness for a given message hash serialized which is an array of the attributes for a given message hash or returns undefined if not found. The hash of the message for which to get the auth goodness returns the serialized auth goodness for a given message hash. The auth goodness, writing a capsule to the capsule dispenser. Fetch is the serialized auth goodness for given message hash. I will link a capsule to the capsule dispenser. The capsule, the fuck is a capsule. An array of the elements representing the capsule. The capsule is a blob of data that is passed to the contract to an article. Exit registers user account in BXE even its master encryption 5K. The user account is registered, the user is will try to decrypt all published notes on the chain storeof the crypto search you should know that the link secret key. PDF is a save, their employee the next question you will ask your Sorbet account over here from illustrated Now get a register accounts. So it retrieves the user accounts registered on this PXI service. And any of the accounts registered on this PXI service, get a register accounts from this computer address. Next is get registered accounts. Okay. So register accounts retrieves the complete address of the account corresponding to the provided address address. Astergadras. Complete addresses include the address, the partial address and the encryption publicly key. Paramys addresses the address of the account, returns the complete address of the requested account, if found. Register a user contact in PFC. Register contact, form sestigatras. Register a user contact, one server new contact will register. We will receive notes tagged from this contact. Ah, far. If nothing is the account is already registered. Paramidras address of the user to add to the address book. Yeah, address address of the account. Register address. It retrieves the address stored as context on this PXI service. Returns an array of the context of this PXI service. We move contact address as jigatras. Re-muse a contact in the address book from this white. Register contract last in the PXI register contract class. Without registering in a specific contract instance, we will. Paramid effect contract artifact. The fuck is it? The build artifact for the contract. The build artifact. Which is the contract in whatever is the binary form. The build artifact. Next is register contract. Actually, the product contract to the PXI service. The product contract information is used to access the contract code when simulated local transactions. This is automatically called by the estigase when deploying the contract. That will wish that we should contract with contract already. We will deploy it. Register contract. Instance contract. Instance with address. Interest of contract. Added to this PXI service. Address register on this PXI service. The register contract class. The address is the instance contract. The contract will. The register contract is the instance. Suppose you get contract from its estigase address. It raises the address of contract to add to this PXI service. It contracts. It is a proving result based on the provided pre-authentic data execution request. So this is a booties. This is here. We are getting to stressing stories. Execution request and the results of executing the private part of the transaction of booties for everything. This will assemble the zinolish boot for the private class. It returns object that contains the proof and public input of the tings. It can be converted into a text ready to be sent to the network. The proof and public input parameters tx request. Private execution result. It returns object ready to be sent. It is a state thing. The code for the function is not being made available. Go ahead with the context. Also, thisÆ°á»›c template for the strÉˆ and public simulation. This signal transaction on the provided updated etcetera examine that in unity i slap some oh I see simulate and constrained get an encrypted loss, get block number, get proven block number, get nodding for get Bx input, is global states synchronized, is a constates synchronized, get sing status, get sing state, get contract instance, get contract class, get contract this contract class publicly registered, is contract publicly deployed, is contract initialized, returns the events of a specified type even such parameters, bar and type, bar and bar and we want metadata, bar and bar and we make bar and we take S returns, get data type, even metadata, from number, limit number, Bx point, bar, e is contract initialized, query is the nodure to check whether, the contract is contract publicly deployed, whether the given address has been publicly deployed, where is the nodure to check whether the contract class with the given ID has been publicly registered, get contract artifact, returns contract certificate, get contract certificate, transfer, get contract instance, returns the nodure to check whether the contract class has been contract instance, promised contract instance, then we find, returns a contract instance, given it is address, which includes the constant, there is a department's hard time publicly this, returns the nodure to check whether the contract class has been identified, initialization has to be promised hard publicly, returns, get seeing status, the largest lock that has been seen twice globally and for each account, the global block number indicates that the global state has been updated up to that block, there are seen status indicates, to which block the private state has been logged, this global state has been realized, which is a specific amount is being realized, found, deprecated, verksing status instead, we marks, checks whether all the source, checks as checking a sync status of account, which is not registered, these global states are synchronized from a spuleon, one of the blocks where processed, triggered data, it took separated through, returns information about this PXC, get nodure information about this PXC, get through and block number, returns the information about the server's node version, compatible non-noyabushan, returns the information about the server's node, it took current node version, compatible non-wushan, it went chain identified for the block number, get block number, get an input loss, that is provided free to, there are lots, request or loss, similarly to constraint function means string arts function on a desired contract without actually modifying state, this is cool to inspect contract state, for example, using a variable value or calling a get-up function, function takes function name, get block, the blocks requested block number being requested, now get block, and nullify it is not, actually, not if nullify node through the database, cross the node thread, not has of the node stress and existing that is, let us design node, nullify node, okay, I will note, nullify node, nullify node, okay, it is our going node self account, so just starting this PXC based on the way, get a data filter, parameter filter filter to apply to nodes, get a L1 to L2 number ship thickness, fetch us an L1 to L2 message from the node node, contract address message has secret contract address in secret, it is only used to compute, returns L1 to L1 to L1, she witnessed index over a message in the tree and seeding part, okay, getting the node, get-public story get, get the storage value, it the given contract storage slot contracts, the max, the storage slot here, first to the slot as it is defined in one, not the index in the mercury tree. As takes version of the heat, get storage at, get storage at, okay. Param contracts slot, slot to query, which is the no, no on name for it, no on in slot. The terms storage value is the given contract slot if the contract is not applied. Get takes repeat transaction receipt, get it takes effect. Param requested text perfect, the hash of transaction, which results in the return to the exact. Which is a transaction receipt for a given transaction hash returns, our mind received, if it was added, to the chain, a pending receipt if it still in the mimpul of the transaction hash or receipt if not found in the connected hash signal. Returns of mind receipt if it was added, get takes, it first has transaction it for a given transaction hash. Returns of mind receipt if it was added, to the chain, a pending receipt if it still in the mimpul. Yep, receipt or transaction, sentix, which is a transaction receipt for a given transaction hash. It can say mind receipt, it is a chain pending receipt, okay, let us get receipt. What about sentix, sends a transaction to an as take note, the broad cast, it will work and mind, param, tx, the transaction is created by a proof takes, returns a hash of transaction used to identify sentix, tx, tx, tx, promise transaction is created by a proof takes, okay, I have proof takes, okay, data by a proof, param, okay, it is first takes, two takes, sends a transaction to an as take note, to the broad cast, to the network and mind, the hash of the transaction used to identify it. Thanks, actually, hash. Then simulate transaction, okay, I think will come this far. What a proof takes, what does it do, return, well, takes, proving this out, okay, so that is what it does, here is simulated transaction based on the provided pre-authenticated execution request. This will run a local simulation or private execution and optionally protocol rules without generating a proof and return these simulation results. Fuck, come on, kernel circuits, fuck, I forget where is the reference. Note that this used with contract function interaction, simulate tx, to bypass certain checks, that case the transaction return is only potentially ready to be sent to the network for execution. Note that this is used with contract function interaction, simulate tx, to bypass certain checks, IEC. The run a local simulation, so to speak, ensure a general protocol rules, and then you can see the data, the data, the data, the data, the data, the data, commissioning, so to speak, R, re-thieve all of this, what not. We need to help you understand the information about the particular solution cloud and a Shinfigure Re- earthly facility. a currently optional and will default all right. Simulated transaction result object that includes public and private return values. If the code for the functions executed in this transaction has not been made available where I had contract also throws it similarly from the list to and from the simulation to what. That includes public and private return values. So, okay, all right, I think we have come at them our whole graph, the contribution I store each, because store is next, partners, and fucking, oh fuck, trees, the interactions Yes. Inastic private data and public data stored in two trees, a public data tree and a note has history. These trees have in common that they store state for all accounts on the as technic work directly as leaves. This is different from Ethereum, where a state try contains smaller tries that hold the individual account storage. It also means that we need to be careful about how we allocate storage to ensure that they don't collide. You see that storage should be siloed in its contracts, goods contracts. The exact way of selling differs a little from public accounts, so it which you will see in the following sections. Okay, public state slots, as mentioned in state model, public state, here is similar, where it is a state model, state model concepts. I think that comes in for further storage. No, now state model there, further down. As take public state, we are similar to public state of Ethereum from the point of view of the level of the, behind the scenes, however, the storage is managed differently. As mentioned, public state has just one large pass tree in Aztec. Yes, so we siloed slots of public data by hashing it together with the contact address. I see. The mental model is that we have a key value store and when the siloed slot is the key and the value in the data stored in that slot is the data stored in that slot. You think of the real storage slot, identifying it is pushing in the tree, the logical storage store, identifying the position in the contract storage. Okay, we also installed in a hash of contract address and logical storage slot. Okay, for form by coincidence. Okay, let's go. Let's go. Let's go. For structs and arrays, we are logically using a similar storage slot computation to Ethereum. As a struct with three fields would be stored in three consular slots. I see logical slots. However, because the actual storage slot is computer as a hash of the contact address and but will the actual storage slot is not consecutive? Fair enough, fair enough. Okay, so the storage slot is a different piece. I assume I can remember from hybrid state model, but I would state. Okay. So, this is a very simple way to make sure that the storage slot is not being opened only means that leaves are never updated or deleted. Instead of nullifier is emitter to signals, you can find that some note is no longer valid. The major reason used this tree is that the lookup looks up at a specified storage slot would be information in the context of private state. If you look up a specific address balance just by looking at the storage slot, even if encrypted, you would be able to see changing. This is not a non-goop privacy. Private storage is a different piece, as you might remember from hybrid state model, private state is stored in the encrypted logs. Yeah, and the corresponding private state commitments in append only trees. Yeah, the corresponding private state commitments in append only tree, where each leaf is a commitment. Being append only means that the leaves are never updated or deleted. Instead, a nullifier is emitter to signify that some note is no longer valid. The major reason we used this tree is that lookup set a specific storage slot would be information. Is that lookup set a specific storage slot would be information in the context of private state? If you look up a specific address balance just by looking at the storage slot, even if you are encrypted, you would be able to see changing. You can't. I see. Following this, the storage slot, as we know, it doesn't really exist. The leaves of the note, hash is tree, or just commitments to content. Think of it as hash of its content. Content of the tree of the note. Nevertheless, the concept of storage slot is very useful when writing applications. Since it allows us to reason about distinct and disjoint piece of data, for example, we can see that the balance of an account is stored in a specific slot and that the balance of the account is stored in another slot with the total supply stored in it, sometimes for a slot. By making sure that these slots are disjoint, we can be sure that balance around mixed up and that someone cannot use the total supply as their balance. But how? If we include the storage slot as part of the note, whose commitment is stored in the note hash is tree, we can logically link all the notes that make up the storage slot. As part of the note, whose commitment is stored in the note hash is tree. Logically, we can see that balance is the sum of all the notes for a particular storage slot. The same way that your physical balance might be the sum of all the notes in the one letter. Similarly, to how we see load siloed, the public storage slots, we can silo our private storage by hashing the logical storage slot together with the note content. Note hash, it's logical storage slot, not content hash. That siloing will be more, is done in the application circuit, since it is not necessary for security of the network. Logically, logically, the stored note content hash is not content hash. Logically, the stored storage slot hash of it is not hash. That siloing is done in the application circuit, since it is not necessary for security of the network. When reading the values, when reading the values of these notes, the applications are kept and then constraint the values to only read notes. With a specific logical storage slot, to ensure that one contract cannot insert storage, that other contract should be used there. We do a second siloing by hashing the commitment with the contact address. The inserted commitment string to rule and not lie about the contractors. The initial notes are the concepts that allows us to commit to an encrypted value and allow us to counterpartit to update that value without knowing the specific details of the encrypted value. Use cases, why is this useful? This is case where a user wants to pay for a transaction fee using a fee payment contract, and the transaction fee will be because the state of the network will have progressed by the time the transaction is processed by the sequence and the transaction fees are dynamic. So the user can commit to a value for the transaction fee, public you post this commitment, P-Bair, a Kada Bay Master can update the public commitment, deducting the final cost of the transaction from the public mentor return in an initialized user. For example, the user is doing some computation by it, encrypt, pressing that computation point, passing the coin as an argument to a public function, and the payments choice updating that point in public, treating them, it results as an owner. The idea of committing to a value, the allowing the counterparty to update that value. The unknown specific details are included, the value is a powerful concept that can be used in many different applications, for example, this could have been used for updating time time values in private. Without revealing like that time stamp, which could be useful for many new applications. The level is the problem properties of elliptic cooperation, good fucking caught, brought in elliptic curves into the future. X and X go 1 star g plus X and X go 2 x 1 into generator plus X 2 into generator equals X 1 equals X star g being a one different function. When X is fragged, both X and X isï¿½ï¿½. 2 times x is currently one to start the swap. Then another to claim the swap tokens from the Dex. The partial nodes can create a node with zero value for the receives the mod and have another party completely clear for the public function with the final swap the mod. This reduces the number of transaction needed to swap priority. Comparing this to flow that flow of all, user is doing some private computation to stage the swap and scripting the computation with a point and passing the point as an argument of leaf function. Then another party is updating that point in public and emptying the result as a node has for the user through the swap. Encrypting the computation with the point and passing the point as an argument to a public and then another party updating that point in public and admitting that it is for two or some more has to be user in public swap. The fact a similar pattern can be used for lending protocols. User can deposit certain amount of token in the lending contract and create a partial node for the borough token that will be completed by another party. This reduces the number of required number of required transaction in two to one. To the lending contract and create a partial node for the borough token that will be completed by another party. This reduces the number of required number certain amount of tokens to the lending contract and create a partial node to the borough token that will be completed by another party. The partial node for the borough token and that person will be listed that party will be listed that borough token in the account. Private refunds. Private transaction refunds from paymaster's original inspiration for partial nodes. Without partial nodes, you have to claim your refund node. But the act of claim itself needs cash. What if your overpaid fees on the refund tax? In here, one of the second-order refunds that you need to claim. This creates a never ending cycle. Before getting to partial nodes, let's take a party for what is a flow of standard nodes. Fuck. Let's go. Before getting to partial nodes, what the flow of standard nodes? In here, another second order. So, they can refund. The master's favorite transaction refunds. The payment security fund is made a commitment from the flow of standard more flow. Then, he says follows, create a noting your contract and create, compute the node to hash. Emit the node hash. Emit the node. As an intubed node log, you can set the x-tera. Create a noting your contract. Compute the node hash. Emit the node hash. Emit the node. As an intubed node log. Emit the node hash. Sequencer, accept the transaction of the node log. Transaction. Include setting a block. Emit the node log. Emit the nodes. Emit the node. Emit the node goal. Emit the node. Emit the node. Emit the node. Emit the node. on chip here. Moves and PXC is following the network. Pick up, back. Pick up the new block, update it in external state and if they have accounts attached, they search for relevant and cryptic note blocks. If we use the PXC finds a lot, it stores the note in its database. Later on, when we want to spend a note in the contract obtained it via Oracle's and stores a note hash read request within the function context. Note hash read request contains a newly computed note hash. Based on the note and the nullifier secret key, nullifier is computed and emitted. What are also fifths check that? The note is a valid note by checking that the note hash read request corresponds to a real note in the note hash tree and that the nullifier does not get exist in nullifier. This is a clarifying. You can note and TXC is following a network here. If I use the TXC finds a lot, stores the note in its database. Can identify? TXC finds a lot, so it can identify that the log has a note, which is relevant to itself. Later on, when we want to spend a note, the contract obtains it via Oracle and stores a note hash read request within the function context. Note hash read request contract. Note hash read request contains a newly computed note hash. Note hash read request contains a newly computed note hash. Based on the note and nullifier secret key, a nullifier is computed and emitted. Protocol supports check that the note is a valid note by checking that the note hash is written on when you want to spend a note contract with the function context. And stores a note hash read request within the function context. Note hash read request contains a newly computed note hash. Based on the note and nullifier secret key, nullifier is computed and emitted. Protocols have it checks that the note is valid note by checking that the note hash read request corresponds to a real note in the note hash read and that the nullifier does not detect this is the nullifier. So, the conditions in point 10 as identified in the nullifier is inserted. Yeah, so the nullifier and the note is at the end of the cycle. Not so simple partial note hash read a partial and pitch note in a private function of your contract. Partial here means that the value within the note are not yet considered finalized example amount in a unique note. Concert a note hiding point of the partial note using a multi-skiller multiplication on the elliptical. But means note this would be done real note. Let me pass the note close. Pass the note hiding point to the public function. In a public function we demand the value you want to add to the note adding the value to the amount and add it to the note hiding point. Get the note hash by finding the note hiding point. M with the note hash. M with the note hash. M with the value added to the note in public has an unencrypted log. T x e then matches it with an encrypted partial note log. M with a private. From this point on the flow partial note is the same as for normal notes. A private fee payment example. I will just want to use a fee payment contract for the abstraction and want to use private balances that is she wants to pay the fee payment contract some amount and so on. I will just want to get a refund. The same token example is that the fee does not know the value is going to run public functions in which case it does not know what a refund is to you. The problem is that the fee does not know if value is going to run public functions which case it does not know what a refund is due until the end of the public. The solution and we cannot use the normal flow to create a transaction fee refund. Note for all is since that demands we have all is addresses address in public. So we define a new type of note with its compute note hiding point defined as. The address in the G address plus random is in G random plus log into G slot. Suppose Alice is willing to pay up to the set amount in stable transfer transaction. Note this amount gets passed into public so that when transaction fees is known if we see can verify it says in the logic money. While it is expected. What is that easy payment contract? Then we can subtract the set amount from Alice's balance of privacy. We will go and create a point in private like EA dash. Alice address in the G address ran a G randomness and Alice notes slot into G slot. We also need to create a point for the owner of the PC whom we call Bob. To receive the transaction fee which will also need randomness. So in the contract we have to run the B hash of random A message sender. EB hash. Yeah. Bob address into G address. General address. Run the B into G randomness. Bob mode slot. We start here. The key. The notes that we are going to create for Alice in Bob. We can use points as partners. The pass is points and the funded amount is public and the end public is reducing. We compute. She point P.P. Into G amount. And the P.P. Then we arrive at the point that corresponds to the complete note. By P.A equals this P.A dash plus P.P.P.P.P.P. Then we just emit P and the score A into X. And P and the score B into X as the more hashes. And we have done congratulations. Very simple and very easy. The notes interface.nr. Intimence.comput.nr. Hiding point. It takes a note and computes the point. Hits it. This is implemented by applying the partial note attribute. You invoke. Bob struck you. Note. The amount of tokens in the note. Value you continue. 28. Owner. At the address. And the miss field. Those G and the score X and generator generated here. And here you invoke. Yeah. Those G and the score X are generators that generated here. Anyone can use them to separate in different fields in a partial note. We can see that it computes implementation of creating and completing the partial notes in a ns take content. This is a pre-fine. Park. The set of different functions is completely different function. To be called at the end of the public functional execution. This ensures that the partial note will be completed. The fee pay will be paid and user refund will be issued. Feature. So pattern of making public commitments to note that can be modified by another party private league. Can be generalized to work with different kinds of applications. Work. The SDGLF team is working on additional adding lacries and pooling to make this easier. If you maintain your own contract. The particular section of the protocol is going to be latest information on the trees And. We will put in the, all right, all right. We start because we will introduce the concept of an indexed mercury and how it can be used to improve the performance of nullified trees in circuits. This page will answer why we need nullified trees at all, how indexed mercury, chemical trees work. This page will answer why we need nullified trees at all, how indexed mercury does work, how they can use for membership exclusion proofs, how they can leverage batch insertions to the products of using next mercury. Hello everyone, today we have an asset and we'll be talking about indexed mercury. Welcome everyone and welcome LASA and the Flurry Cheers. So I'm LASA from domestic and we talked about indexed mercury for this session and solicitation of general BSDs, we've shown you going all of what is aspect and why to even have interest in these trees, then go over our legacy nullified asset up, how indexed trees make sense for us and some of the intuition of why or how they work and then essentially we end up with profit by having a smaller circuit at the end. So we can show you for FSTG for those that don't know we are working on building any layer 2 that's having private smart contracts. And so this means that we also end up having a lot of private state that we need.