 Ok, documentation of astick. You are looking at function at reboots and macros. The part of smart contracts documentation. The function matters. Private functions. Private function operates on the right of the function. The part. Ok, because it may need feedback. But, the function matters. The function matters. The function matters. Private functions. Private function operates on private information. And is executed by the user on their device. Annotate the function with the private attribute to tell the compiler it is a private function. This will make the private context available within the function's execution scope. The compiler will create a certain different function. It will be a state-naldo. Private is just a syntax-figure. It compiled time. I'll take an NAR framework and insert a code that allows the function to interact with the kernel. What did? Well, illustrate how this interacts with the internals of astick and its kernel circuits. We can take an example of, can take an example of a private function. And explore what it looks like after astick.nars macros expansion. Push-and-tune. Before expansion. Before expansion. Simple macros example. Private function. If you want to see the example. Feel a full B, feel a full B. After expansion. Simple macro example. Function. Simple macro example. Input. Private context. Private context. Private circuit. Public inputs. The hash in is a structure. You use to generate a hash of the circuit. Let me read. Arxz and his co-hassure. It's a dependent astick hash. Arxhassure. Arxhassure. Add. Arxhassure. Add.B. The context object is created. Okay. Oh fuck. So this is what's expanded into. The prior context inputs are made available to the circuit. Input. Private context input. A.B. A.B. Input. Input. Actually, written type. Of a circuit is a private input to a kernel. Okay. Public input. Okay. Public input. You actually just have to. You used to generate a hash of the circuit. That. Red means. Red means. Red means. Red means. White means. The unhappy spirits. Red means. Red means. Well. let the new two context to write context to the new puts a reverse Rosharash Hmm On the side of the state it Let me show you the story groups in context Yeah Our actual program that result equals B Return values are pushed into the context Let move to the hashar equals Return hashar at result Context written on hash Context finish Oh, that's better Fuck, in return happens Alright This is cool, yeah, yeah, yeah Helper information The expansion broke and down Oh, why you break down the expansion Newing the expanded as to contract uncovers A lot about how I stuck contracts interact with the kernel It's a great way with the developing intuition We will break down I write my intuition is developed Because I've already read the context The right one context The dog one context Reserving context from the kernel Context example inputs Impulse private context inputs Fuck in discreation I think I Spanked on my bottom Feels like Private function calls are able to interact With each other through orchestration From within the kernel circuits The kernel circuit Forward information to each contract function We call each contract function is a circuit The information then becomes part of the private context Each other through orchestration from within the kernel circuits The kernel circuit powers information to each contract function Recall each contract function is a circuit Yeah, that's what I'm talking Which contract function I was told Is a very indication key Not a circuit This information then becomes part of the private context For example, within each private function We can access some global variables To access them we call on the context context.chain ID The value of the chain ID comes from the value's past Into the co-circuit from the kernel You can check that all the values passed to each circuit in the function Call are the same To each circuit The kernel checks that all the values passed to each circuit In a function call are the same To each circuit In a function call are the same The context to the kernel The context example is done For private circuit public inputs All right The contract function must be written in full data The information about the execution back to the kernel This is done through a register structure We call the private circuit public inputs Why is it called the private circuit public inputs When verifying ZK programs Return values are not computed at verification runtime Rather expected return values are provided as inputs And check for correctness As a return value are considered public inputs This structure contains a host of information about the execution program It will contain any new created nullifiers Any messages to be sent to L2 And most importantly contain the recon values of the function What is the hashare and YZT did inside the kernel circuits The inputs to functions are reduced to single value to a single value The input hash This prevents the need for multiple different kernel circuits It's supporting different number of inputs The hashare abstraction that allows us to create an array of all the inputs that can be reduced to single value The input hashare abstraction is done The input hashare abstraction is done The input hashare abstraction is done Rather expected return values are provided as inputs and check for correctness And the return values are considered public inputs This structure contains a host of information about the execution program It will contain all new created nullifiers any messages You sent it to L1 And most importantly contain the return values of the function Hashing the function in groups Notes, on-unite files, not content Hashing the function in groups On-text example hashare Let new darks hashare, here, here, here, here, here, here, here I saw that darks hashare array, our hashare array What is the hashare and YZT needed Inside the kernel circuit the inputs to functions are reduced to a single value The input hash, this prevents a need for multiple different kernel circuits Each supporting different number of inputs The hashare abstraction that allows us to create an array of all of the inputs that can be reduced to single lines Creating the function's context Let new context private context new inputs are the answer Each answer function has access to context object All your new development, variable, it is created, locally, on a users device It is initialized from the input provided by the kernel and hashare function in groups Context, context example, context written Context example, context written, let new return hashare Let new return hashare, context written hashare Use the kernel to pass information to the user kit This means that the return values of the functions must also be passed The first one is the function which is by pushing the return values to the execution context This is the first one Making the context sure that we are going to write new story with the story We need to move context The story struck is declared within a contract The story keyword is made available As shown in the macro expansion above, this call is the unit function on the story struck With the current function's context Any state variables declared in the story struck can now be accessed as normal struck Normal struck members Context example finish, context finish, this function takes up The application context and converts it into the private circle public input structure This structure is then passed to the kernel circuit Unconstrained function, unconstrained functions are the underlying part of the world In short, their functions which are not directly constrained And therefore should be seen as untested That they are untrusted, that they are untrusted means that the developer must make sure to constrain their return values Calling an unconstrained function compiling function is that you are injecting an unconstrained values What the fuck? Defining the function as unconstrained tells us to simulate a completely client side in the ACA simulator Without generating proofs, they are usually for extracting information from user through an article When an unconstrained function is called, it prompts the ACA simulator to generate the execution environment Exegude the function within the environment To generate the environment, the simulator gets the block header from the PX database And passes it along with the contract address to view data or record This creates a context that simulates the state of the block chain at a specified blocks Allowing the unconstrained function to access and interact with blocks in data as it could appear in that block But without affecting the actual block chain state The function is to create a function that is not used in the system And passes it along the contract This creates a context that simulates the state of the block chain and is specified block window and unconstrained function to access So it basically updates execution environment with the latest block Yes data is equal to here on the block but without affecting the actual block in state Once the execution environment is created, execute unconstrained function is in there It creates the ACA for execution The execution environment is created, execute unconstrained function is in the Execute unconstrained function, export async function, execute unconstrained function Oracle view data oracle, artifact function and artifact Contract address, async address function selector function selector ArxFR Log create debug logger from is log verbose Cost, constase, AR, artifact, bytecode Cost initial witness to ACVM witness 0 comma x, constase, AR execution result Avatase, VM, Throneu, AR, Message, contract address function selector Extract, crawl stack, const return witness, hit us map to fields Return decode from the via Repesh the ACA for execution, converts args into a former sub-suitable for the ACVM Cleaning an initial witness, witness set of inputs required to complete the function Ox might be an Oracle to request a user's balance, execute the function in the ACVM Which involves running Artifact.bytode, const initial witness to ACVM witness 0 comma x, constacular execution result Avatase, VM, Throneu, Message, contract address, function selector, Extract, call stack, const return witness, witness map to fields, ACVM Execution, error, contract address, function selector, extract, call stack, cost Revolver, return decode from the via, at-charter turn types return witness Repesh the ACA for execution, converts into a former sub-suitable for Affleadness, for the ACVM, exact set of execution Cleaning, initial witness might be an Oracle to request a user's balance, Executes the function in the ACVM, which involves running the ACA Revolver, initial witness, set the context, reticuse Revolver, you can quickly balance from the PXD address, extract, return value from the partial Rittness and decode same based on the artifact, get the final function out The artifact is a compiled output of the contract And has information like the function signature, parameter types and return types Beyond using them inside your own function Executes the function the ACVM, executes the function in the ACVM, which involves And on the ACA, with the initial witness and the context, it requires Still, the user's balance, this would query the balance from the XD address Extract, return value from partial Rittness and decodes them based on the artifact To get the final function output The artifact is the compiled output of the contract and has information Like the function signature, parameter types and return types Beyond using them inside your own functions, they are convenient for providing an interface that reads storage Applies logic and returns value to a UI or test We'll always snippet from exposing the balance of private function From token implementation of each other's user TZ will be given the balance Similarly, the balance of function in the user's standard We are using them inside your functions, they are convenient for providing an interface that reads storage Applies logic and returns value to a UI or test We'll always snippet from exposing the balance of private function From token implementation, which allows user to easily use the function We'll always snippet from the user's standard Similarly, the balance of function in the user's standard You want using them inside your other functions, they are convenient for providing an interface that reads storage Applies logic and return value to a UI or test Below is a snippet from exposing the balance of private function From token implementation, which allows user to easily read their balance of function Note that this function can have access to both public and private data to when executed on the user's device This is possible since it is not actually part of the circuits that are executed in contract execution The problem is that the user can't access the function The problem is that the user can't access the function The problem is that the user can't access the function The problem is that the user can't access the function The problem is that the user can't access the function The problem is that the user can't access the function This will make the public context available within the function's execution scope A public function is executed by the sequencer And has access to a state model That is very similar to that of the EVM kind of thing. Even though they work in EVM like model, the public transactions they are able to write data into private storage that can be consumed later by private function. All data inside of the private storage from public function will be publicly viewable. To create a public function you can annotate it with the public attribute. This will make the public context available within the function's execution scope. Set-miner, meter, public function, set-miner, meter, as take address, approveable, assert storage admin. Read, EQ, context, message, sender, call or is not admin. Storage, mentors, storage, mentors, dot, et meter, write, approve. Under the hood context creation, the macro inserts code at the beginning of the function to create a public context object. Let me context is public context new org's hasher. This context provides access to the public state and transaction information. Storage access, if the contract has a storage track defined, the macro inserts code to initialize the storage. Let's storage equals storage in each mute context. Function body rapings, the original function body is wrapped in a new scope that handles the context and return value. Visibility control, the function is marked as pub, making it accessible from outside the contract. Unconstrained execution, public functions are marked as unconstrained, meaning they don't generate clues that are executed directly by the sequence. Constrained view functions. The view attributes are used to define constrained view functions in as take context. These functions are similar to view functions in solidity in that they are read only and do not modify the contract state. They are similar to the unconstrained keyword but are executed in the constrained environment, it is not possible to update state within and review function. In one given unconstrained function, you cannot state, not possible to update state within and understand it. This means the result of these functions are verifiable and can be trusted as they are part of the feed generation and verification process. This is unlike unconstrained functions, proof generation and verification process. The result is unconstant, the result is unconstant, the result is unconstant, the result is unconstant, the result is unconstant. This makes view functions suitable for critical read only operations where the integrity of the result is crucial. Unconstant functions, on the other hand, are executed entirely client side without generating any proof. It is better to use view if the result of the functions will be used in another function that will affect state and they can be used for cross contract calls. View functions can be combined with other as take a look like private or public. If it is used elsewhere in another function that uses state, balance of tokens, when you retrieve it, well it is not used to be different functions, so it is okay if it is something else. If you want to use it in somewhere else like you want to check the balance before deducting a certain amount of tokens from an account, well then, one thing is you function. Initializer functions, initializer. This is used to designate functions as initializers or constructors for an architect contract. These functions are responsible for setting up the initial state of the contract when it is first deployed, macro does two important things. Assert initialization matches address pre-mage context. This checks that the arguments and sender to the initializer, mass the commitments come to address pre-mage. Mark as initialize, multiple context. This is called at the end of the function, we emit the initialization nullifier, making the context as fully initialized and ensuring this function cannot be called again. This is called at the end of the function. He thinks to keep in mind. Contract can have multiple initializer functions defined, but only one initializer function should be called for the lifetime contract instance. What only one initializer function should be called for the lifetime of a contract instance, I don't understand this. Other functions in the contract will have an un-initialization check-inserted. Okay, the other functions in the contract will have an initialization check-inserted that is they cannot be called until the contract is initialized. Unless they are marked with no in-check. No in-check, the normal circumstances, all functions in anastic contract accept initializers have an initialization check-inserted. If the beginning of the function body, the check-inserted that the contract has been initialized before any other function can be called. However, other there may be scenarios where you want a function to be called, probably regardless of the contract instance state, this is very good news, no in-check. The function under no in-check, theastic matrices are skipped the initiation of the insertion of the initializers check for this specified function, this is a function. The function can be called at any time, even if the contract hasn't been initialized yet. The internal functions, but what if the remarkable initializer function of the contract? The macro-inserted check-in the beginning of the function to ensure that the caller is a contract itself is a conocled contract itself. This is done by adding the following assertions. Asserted, context-message-cender equals context-disadress. Function can only be called, intermere. The code is the contract itself. This is an embedding to the content, assert-contract-context-message-cender equals context-disadress. Custom notes, note, note, the note attribute is used to define custom note types inastic contracts, learn more about notes here. The code is used to define custom note types. The code is used to define custom note types. The code is used to define custom note types. The structure is another way to define custom note types. The code is used to define custom note types. The code is used to define custom note types. The code is used to define custom note types. The code is used to define custom note types. Note type ID. Winning candidates. One is automatically created. Note type ID generation. The unique note type ID is automatically computed for the note type using Kcheck has her the struct name. The code is used to define custom note type ID. Automatic header field. The struct doesn't have a header field of type note header. One is automatically created. Note type ID generation. A unique note type ID is automatically computed for the note type using a Kcheck has of the struct name. The code is used to define custom note type ID generation. The code is used to define custom note type ID generation. The code is used to define custom note type ID generation. The code is used to define custom note type ID generation. The code is used to define custom note type ID generation. The code is used to define custom note type ID generation. The code is used to define custom note type ID generation. The struct custom note data field is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note type ID generation. The code is used to define custom note type ID generation. The code is used to define custom note data field order address. After expansion, the custom note function serialized content cell custom note field not serialized. The serialized content is serialized content. Get note type ID. Get header. Set header. Compute note hiding point. Two bbites. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note properties. The code is used to define custom note properties. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The developer can override this by implementing an include block themselves. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field. The code is used to define custom note data field.